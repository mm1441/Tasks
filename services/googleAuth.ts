import * as AuthSession from 'expo-auth-session';
import * as Crypto from 'expo-crypto';
import * as Google from 'expo-auth-session/providers/google';
import AsyncStorage from '@react-native-async-storage/async-storage';

const GOOGLE_CLIENT_ID = process.env.EXPO_PUBLIC_GOOGLE_CLIENT_ID || '73415059897-bkf2pg91g2k6m8qdluh7bqnicjh34jkp.apps.googleusercontent.com'; // How to set EXPO_PUBLIC_GOOGLE_CLIENT_ID ?
const ANDROID_CLIENT_ID = process.env.EXPO_PUBLIC_ANDROID_CLIENT_ID || '73415059897-3ijunc0ke1pc3lccccocdhj9gl2kv07t.apps.googleusercontent.com';
const GOOGLE_REDIRECT_URI = AuthSession.makeRedirectUri({
  scheme: 'com.magicmarinac.tasks',
});
const TOKEN_STORAGE_KEY = '@google_auth_tokens';
const DISCOVERY = {
  authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',
  tokenEndpoint: 'https://oauth2.googleapis.com/token',
  revocationEndpoint: 'https://oauth2.googleapis.com/revoke',
};

export interface GoogleAuthTokens {
  accessToken: string;
  refreshToken?: string;
  expiresAt?: number;
}

export class GoogleAuthService {
  private static instance: GoogleAuthService;
  private tokens: GoogleAuthTokens | null = null;

  private constructor() { }

  static getInstance(): GoogleAuthService {
    if (!GoogleAuthService.instance) {
      GoogleAuthService.instance = new GoogleAuthService();
    }
    return GoogleAuthService.instance;
  }

  async loadStoredTokens(): Promise<GoogleAuthTokens | null> {
    try {
      const stored = await AsyncStorage.getItem(TOKEN_STORAGE_KEY);
      if (stored) {
        this.tokens = JSON.parse(stored);
        // Check if token is expired
        if (this.tokens?.expiresAt && this.tokens.expiresAt < Date.now()) {
          if (this.tokens.refreshToken) {
            await this.refreshAccessToken(this.tokens.refreshToken);
          } else {
            this.tokens = null;
            await AsyncStorage.removeItem(TOKEN_STORAGE_KEY);
          }
        }
        return this.tokens;
      }
    } catch (error) {
      console.error('Failed to load stored tokens:', error);
    }
    return null;
  }

  async signIn(): Promise<GoogleAuthTokens> {
    if (!ANDROID_CLIENT_ID) {
      throw new Error('Google Client ID not configured. Please set EXPO_PUBLIC_GOOGLE_CLIENT_ID');
    }

    console.debug(process.env.EXPO_PUBLIC_ANDROID_CLIENT_ID)

    try {
      const request = new AuthSession.AuthRequest({
        clientId: ANDROID_CLIENT_ID,
        scopes: [
          'https://www.googleapis.com/auth/tasks',
          'https://www.googleapis.com/auth/tasks.readonly',
        ],
        redirectUri: GOOGLE_REDIRECT_URI,
        responseType: AuthSession.ResponseType.Code,
        usePKCE: true,
      });

      const result = await request.promptAsync(DISCOVERY);
      console.log(result)

      if (result.type === 'success' && result.params.code) {
        // Get code verifier from request (generated by usePKCE)
        const codeVerifier = (request as any).codeVerifier;

        const tokenResult = await AuthSession.exchangeCodeAsync(
          {
            clientId: ANDROID_CLIENT_ID,
            code: result.params.code,
            redirectUri: GOOGLE_REDIRECT_URI,
            extraParams: codeVerifier ? { code_verifier: codeVerifier } : {},
          },
          DISCOVERY
        );

        const tokens: GoogleAuthTokens = {
          accessToken: tokenResult.accessToken,
          refreshToken: tokenResult.refreshToken || undefined,
          expiresAt: tokenResult.expiresIn
            ? Date.now() + tokenResult.expiresIn * 1000
            : undefined,
        };
        console.log("tokens: ", tokens);


        await this.saveTokens(tokens);
        this.tokens = tokens;
        return tokens;
      } else {
        throw new Error('Authentication cancelled or failed');
      }
    } catch (error) {
      console.error('Sign in error:', error);
      throw error;
    }
  }

  async setTokensFromAuthResult(authResult: { accessToken: string; refreshToken?: string; expiresIn?: number }) {
    const tokens: GoogleAuthTokens = {
      accessToken: authResult.accessToken,
      refreshToken: authResult.refreshToken,
      expiresAt: authResult.expiresIn ? Date.now() + authResult.expiresIn * 1000 : undefined,
    };

    await this.saveTokens(tokens);
    this.tokens = tokens;
    return tokens;
  }

  async refreshAccessToken(refreshToken: string): Promise<GoogleAuthTokens> {
    try {
      const response = await fetch('https://oauth2.googleapis.com/token', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
          client_id: ANDROID_CLIENT_ID,
          refresh_token: refreshToken,
          grant_type: 'refresh_token',
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to refresh token');
      }

      const data = await response.json();
      const tokens: GoogleAuthTokens = {
        accessToken: data.access_token,
        refreshToken: refreshToken, // Keep the same refresh token
        expiresAt: data.expires_in ? Date.now() + data.expires_in * 1000 : undefined,
      };

      await this.saveTokens(tokens);
      this.tokens = tokens;
      return tokens;
    } catch (error) {
      console.error('Token refresh error:', error);
      await this.signOut();
      throw error;
    }
  }

  async getAccessToken(): Promise<string | null> {
    if (!this.tokens) {
      await this.loadStoredTokens();
    }

    if (!this.tokens) {
      return null;
    }

    // Check if token is expired or about to expire (within 5 minutes)
    if (this.tokens.expiresAt && this.tokens.expiresAt < Date.now() + 5 * 60 * 1000) {
      if (this.tokens.refreshToken) {
        await this.refreshAccessToken(this.tokens.refreshToken);
      } else {
        return null;
      }
    }

    return this.tokens.accessToken;
  }

  async signOut(): Promise<void> {
    try {
      if (this.tokens?.accessToken) {
        // Try to revoke the token
        try {
          await fetch('https://oauth2.googleapis.com/revoke', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
              token: this.tokens.accessToken,
            }),
          });
        } catch (error) {
          console.warn('Failed to revoke token:', error);
        }
      }
    } catch (error) {
      console.error('Sign out error:', error);
    } finally {
      this.tokens = null;
      await AsyncStorage.removeItem(TOKEN_STORAGE_KEY);
    }
  }

  isAuthenticated(): boolean {
    return this.tokens !== null;
  }

  private async saveTokens(tokens: GoogleAuthTokens): Promise<void> {
    try {
      await AsyncStorage.setItem(TOKEN_STORAGE_KEY, JSON.stringify(tokens));
    } catch (error) {
      console.error('Failed to save tokens:', error);
      throw error;
    }
  }
}
